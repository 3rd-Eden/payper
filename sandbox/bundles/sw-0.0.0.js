(()=>{var t={121:t=>{t.exports=function(t,e=self.registration.scope){const a=new URL(e);return a.pathname=`/payper/${[].concat(t).join("/")}`,a.search="",a.href}},795:t=>{t.exports=function({url:t,method:e}){return/\/payper\//.test(t)&&("GET"===e||"HEAD"===e)}},103:(t,e,a)=>{const s=a(121),n={ignoreVary:!0,ignoreMethod:!0,ignoreSearch:!0};t.exports=class{constructor(t){this.name=`payper@${t}`,this.version=t,this.format=s}async clean(){const t=await caches.keys(),e=this.version;for(let a=0;a<t.length;a++){const a=t[0];a.startsWith("payper@")&&a.split("@")[0]!==e&&await caches.delete(a)}}async missing(t){bundle;const e=await caches.open(this.name);return(await Promise.all(t.map((async t=>await e.matches(this.format(t.bundle))?null:t)))).filter(Boolean)}async gather(t){const e=await caches.open(this.name),a=await Promise.all(t.map((t=>e.match(this.format(t.bundle),n))));return this.hit(t),a}async hit(t){const e=await caches.open(this.name);t.map((async t=>{const a=this.format(t.bundle),s=await e.match(a,n);s.headers.set("payper-hit",Date.now()),await e.put(a,s)}))}async fill(t){const e=await caches.open(this.name);await Promise.all(t.map((function({bundle:t,response:a}){return this.format(t),a.headers.set("payper-hit",Date.now()),e.put(a)})))}async invalidate(t){const e=await caches.open(this.name),a=await e.keys(),s=Date.now();a.forEach((async function(a){const i=+(await e.match(a,n)).headers.get("payper-hit");(!i||s-i>t)&&await e.delete(a,n)}))}}},623:(t,e,a)=>{const s=a(121),n=a(795),i=a(103);t.exports=class{constructor({version:t,ttl:e}={}){this.cache=new i(t),this.settings={ttl:e},this.format=s,this.matches=n}register(){["fetch","activate","install"].forEach((t=>self.addEventListener(t,this[t].bind(this))))}install(){self.skipWaiting()}async activate(){self.clients.claim(),await this.cache.clean(),await this.cache.invalidate(this.settings.ttl)}fetch(t){const{request:e}=t;t.respondWith((async()=>{const t=this.extract(e.url);if(!this.matches(e)||!t.length)return fetch(e);const a=await this.cache.missing(t);if(a.length)try{await this.preload(a,{url:e.url})}catch(t){return fetch(e)}return this.respond(t)}))}async preload(t,{url:e}){const a=t.map((({bundle:t})=>t));let s=await fetch(this.format(a,e));if(!(s.ok&&s.status<400))throw new Error("Unable to fetch the optimized payer bundle");const n=await s.text(),i=this.parse(n);await this.cache.fill(i)}async respond(t){const e=await this.cache.gather(t),a=new Blob(e,{type:"text/javascript"});return new Response(a,{status:200,statusText:"OK"})}parse(t){const e=[],a="/*! Payper meta(";let s=t.indexOf(a);for(;~s;){const n=t.indexOf("\n",s),i=t.slice(s,n),r=new Blob([t.slice(0,n)],{type:"text/javascript"}),c=new Response(r,{status:200,statusText:"OK"}),{name:o,version:h,cache:l}=(/meta\(([^)]+?)\)/.exec(i)[1],JSON.parse(i)),p=`${o}@${h}`;l&&e.push({name:o,version:h,bundle:p,response:c}),s=(t=t.slice(n+1)).indexOf(a)}return e}}}},e={};(new(function a(s){var n=e[s];if(void 0!==n)return n.exports;var i=e[s]={exports:{}};return t[s](i,i.exports,a),i.exports}(623))).register()})();